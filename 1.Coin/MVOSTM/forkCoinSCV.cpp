#include <iostream>
#include <thread>
#include "Util/Timer.cpp"
#include "Contract/CoinSCV.cpp"
#include "Graph/Lockfree/Graph.cpp"
#include "Util/FILEOPR.cpp"
#include <unistd.h>

#define MAX_THREADS 128
#define M_SharedObj 5000
#define FUN_IN_CONT 3
#define pl "=================================================================\n"
#define MValidation true   //! true or false
#define numValidator 50
#define InitBalance 1000
#define NumBlock 26        //! at least two blocks, the first run is warmup run.
#define malMiner true      //! set the flag to make miner malicious.
#define NumOfDoubleSTx 2   //! # double-spending Tx for malicious final state by Miner, multiple of 2.


using namespace std;
using namespace std::chrono;

int    SObj    = 2;        //! SObj: number of shared objects; at least 2, to send & recive.
int    nThread = 1;        //! nThread: total number of concurrent threads; default is 1.
int    numAUs;             //! numAUs: total number of Atomic Unites to be executed.
double lemda;              //! % of edges to be removed from BG by malicious Miner.
double tTime[2];           //! total time taken by miner and validator algorithm.
Coin   *coin;              //! smart contract.
Graph  *cGraph;            //! conflict graph generated by miner to be given to validator.
int    *aCount;            //! aborted transaction count.
float_t*mTTime;            //! time taken by each miner Thread to execute AUs (Transactions).
float_t*vTTime;            //! time taken by each validator Thread to execute AUs (Transactions).
vector<string>listAUs;     //! holds AUs to be executed on smart contract: "listAUs" index+1 represents AU_ID.
std::atomic<int>currAU;    //! used by miner-thread to get index of Atomic Unit to execute.
std::atomic<int>gNodeCount;//! # of valid AU node added in graph (invalid AUs will not be part of the graph & conflict list).
std::atomic<int>eAUCount;  //! used by validator threads to keep track of how many valid AUs executed by validator threads.
std::atomic<int>*mAUT;     //! array to map AUs to Trans id (time stamp); mAUT[index] = TransID, index+1 = AU_ID.
std::atomic<int>*status;   //! used by pool threads:: -1 = thread join; 0 = wait; 1 = execute AUs given in ref[].
Graph::Graph_Node **Gref;  //! used by pool threads:: graph node (AU) reference to be execute by respective Pool thread.
Graph  *nValBG;            //! used to store graph of respective n validators.
int MinerState[M_SharedObj];
int ValidatorState[M_SharedObj];
std::atomic<bool>mm;       //! miner is malicious, this is used by validators.



/*************************Miner code begins************************************/
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!    Class "Miner" CREATE & RUN "n" miner-THREAD CONCURRENTLY           !
!"concMiner()" CALLED BY miner-THREAD TO PERFROM oprs of RESPECTIVE AUs !
! THREAD 0 IS CONSIDERED AS MINTER-THREAD (SMART CONTRACT DEPLOYER)     !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
class Miner
{
	public:
	Miner(int minter_id)
	{
		cGraph     = new Graph();
		//! initialize the counter used
		//! to execute the numAUs to 0.
		currAU     = 0;
		//! initialize the graph node counter to 0
		//! (number of AUs added in graph, invalid
		//! AUs are not part of the grpah).
		gNodeCount = 0;
		//! array index location represents
		//! respective thread id.
		mTTime     = new float_t [nThread];
		aCount     = new int [nThread];
		for( int i = 0; i < nThread; i++ ) {
			mTTime[i] = 0;
			aCount[i] = 0;
		}
		//! id of the contract creater is "minter_id".
		coin = new Coin(SObj, minter_id);
	}

	//!------------------------------------------------------------------------- 
	//!!!!!!!! MAIN MINER:: CREATE MINER + GRAPH CONSTRUCTION THREADS !!!!!!!!!!
	//!-------------------------------------------------------------------------
	void mainMiner()
	{
		Timer Ltimer;
		thread T[nThread];
		int ts, bal = InitBalance;
		//! initialization of account with fixed
		//! ammount; mint() is assume to be serial.
		for(int sid = 1; sid <= SObj; sid++) {
			//! 0 is contract deployer.
			coin->mint_m(0, sid, bal, &ts);
		}

		//!!!!!!!!!!    Create nThread Miner threads      !!!!!!!!!!
		double start = Ltimer.timeReq();//! start timer.
		for( int i = 0; i < nThread; i++ ) 
			T[i] = thread(concMiner, i, numAUs, cGraph);
		for( auto &th : T) th.join ( );
		tTime[0] = Ltimer.timeReq() - start;

		//! print conflict grpah generated by miner.
//		cGraph->print_grpah();
//		FILEOPR file_opr;

		//! print AU_ID and Timestamp.
//		file_opr.pAUTrns(mAUT, numAUs);

		//! print the final state
		//! of the shared objects.
		finalState();
	}


	//!--------------------------------------------------------
	//! The function to be executed by all the miner threads. !
	//!--------------------------------------------------------
	static void concMiner( int t_ID, int numAUs, Graph *cGraph)
	{
		Timer Ttimer;
		//! flag is used to add valid AUs in Graph (invalid
		//! AU: senders does't have sufficent balance to send).
		bool flag   = true;
		//! get the current index, and increment it.
		int  curInd = currAU++;
		//! statrt clock to get time taken by this transaction.
		auto start  = Ttimer._timeStart();
		while(curInd < numAUs)
		{
			//! trns_id of STM_BTO_transaction that
			//! successfully executed this AU.
			int t_stamp;
			//! trans_ids with which this
			//! AU.trans_id is conflicting.
			list<int>conf_list;
			//! get the AU to execute, which is of string type.
			istringstream ss(listAUs[curInd]);
			string tmp;
			ss >> tmp; //! AU_ID to Execute.
			int AU_ID = stoi(tmp);
			ss >> tmp; //! Function Name (smart contract).
			if(tmp.compare("get_bal") == 0)
			{
				ss >> tmp; //! get balance of SObj/id.
				int s_id = stoi(tmp);
				int bal  = 0;
				//! get_bal() of smart contract.
				bool v = coin->get_bal_m(s_id, &bal, t_ID, &t_stamp, conf_list);
				while(v == false) //! execute again if tryCommit fails.
				{
					aCount[t_ID]++;
					v = coin->get_bal_m(s_id, &bal, t_ID, &t_stamp, conf_list);
				}
				mAUT[AU_ID-1] = t_stamp;
			}
			if(tmp.compare("send") == 0)
			{
				ss >> tmp; //! Sender ID.
				int s_id  = stoi(tmp);
				ss >> tmp; //! Reciver ID.
				int r_id  = stoi(tmp);
				ss >> tmp; //! Ammount to send.
				int amt   = stoi(tmp);
				int v = coin->send_m(t_ID, s_id, r_id, amt, &t_stamp, conf_list);
				while(v != 1 ) //! execute again if tryCommit fails.
				{
					aCount[t_ID]++;
					v = coin->send_m(t_ID, s_id, r_id, amt, &t_stamp, conf_list);
					if(v == -1) {
						//! invalid AU: sender does't
						//! have sufficent balance to send.
						flag = false;
						break;                                    
					}
				}
				mAUT[AU_ID-1] = t_stamp;
			}

			//! graph construction for committed AUs.
			if (flag == true)
			{
				//! increase graph node
				//! counter (Valid AU executed).
				gNodeCount++;
				
				//! IMP::delete time stamps in conflict list, which are added
				//! because of initilization version by mnit() trycommit.
				for(int y=0; y<=2*SObj; y++) conf_list.remove(y);

				//!------------------------------------------
				//! conf_list come from contract fun using  !
				//! pass by argument of get_bel() and send()!
				//!------------------------------------------
				//! when AU_ID conflict is empty.
				if(conf_list.begin() == conf_list.end()) {
					Graph:: Graph_Node *tempRef;
					cGraph->add_node(AU_ID, t_stamp, &tempRef);
				}

				for(auto it = conf_list.begin(); it != conf_list.end(); it++)
				{
					int i = 0;
					//! find the conf_AU_ID in map table
					//! given conflicting time-stamp.
					while(*it != mAUT[i]) i = (i+1)%numAUs; 
					//! because array index start with
					//! 0 and index+1 respresent AU_ID.
					int cAUID   = i+1;
					//! conflicting AU_ID with this.AU_ID.
					int cTstamp = mAUT[i];
					//! edge from conf_AU_ID to AU_ID.
					if(cTstamp  < t_stamp)
						cGraph->add_edge(cAUID, AU_ID, cTstamp, t_stamp);
					//! edge from AU_ID to conf_AU_ID.
					if(cTstamp > t_stamp)
						cGraph->add_edge(AU_ID, cAUID, t_stamp, cTstamp);
				}
			}
			//! reset flag for next AU.
			//! get the current index  to
			//! execute, and increment it.
			flag   = true;
			curInd = currAU++;
		}
		mTTime[t_ID] = mTTime[t_ID] + Ttimer._timeStop( start );
	}

	//!-------------------------------------------------
	//!FINAL STATE OF ALL THE SHARED OBJECT. Once all  |
	//!AUs executed. we are geting this using get_bel()|
	//!-------------------------------------------------
	void finalState()
	{
		list<int>cList;
		for(int sid = 1; sid <= SObj; sid++) {
			int bal = 0, ts;
			//! get_bal() of smart contract, execute again if tryCommit fails.
			coin->get_bal_m(sid, &bal, 0, &ts, cList);
			MinerState[sid] = bal;
		}
	}
	~Miner() { };
};
/*************************Miner code ends**************************************/





/*************************Validator code begins********************************/
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Class "Validator" CREATE & RUN "n" validator-THREAD   !
! CONCURRENTLY BASED ON CONFLICT GRPAH GIVEN BY MINER.  !
! "concValidator()" CALLED BY validator-THREAD TO       !
! PERFROM OPERATIONS of RESPECTIVE AUs.  THREAD 0 IS    !
! CONSIDERED AS MINTER-THREAD (SMART CONTRACT DEPLOYER) !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
class Validator
{
public:
	Validator()
	{
		eAUCount = 0;
		//! thread id represents index location.
		vTTime = new float_t[nThread+1];
		status = new std::atomic<int>[nThread+1];
		Gref   = new Graph::Graph_Node*[nThread+1];
		for(int i = 0; i <= nThread; i++) {
			status[i] = 0;
			Gref[i]   = NULL;
			vTTime[i] = 0;	
		}
	};
	
	//!-------------------------------------------------
	//! CREATE MASTER THREADS: CREATES n WORKER        !
	//! THREADs TO EXECUTE VALID AUs IN CONFLICT GRAPH.!
	//!-------------------------------------------------
	void mainValidator()
	{
		for(int i = 0; i <= nThread; i++) vTTime[i] = 0;
		eAUCount = 0;

		coin->reset();

		Timer Ttimer;
		int bal = InitBalance, total = 0;
		//! initialization of account with fixed ammount;
		//! mint_val() function is assume to be serial.
		for(int sid = 1; sid <= SObj; sid++) {
			bool r = coin->mint(0, sid, bal); //! 0 is contract deployer.
			total  = total + bal;
		}

		//!----------------------------------------------------
		//! MASTER THREAD CREATE n VALIDATOR THREADS          !
		//!----------------------------------------------------
		double start = Ttimer.timeReq();
		thread master = thread(concValidator, 0 );
		master.join();
		tTime[1] = Ttimer.timeReq() - start;

		//! print the final state of the shared objects by validator.
		finalState();
	}

	//!--------------------------------------------------------
	//! The function to be executed by all Validator threads. !
	//!--------------------------------------------------------
	static void concValidator( int t_ID )
	{
		Timer Ttimer;
		//! start timer to get time taken by this thread.
		auto start = Ttimer._timeStart();
		//! ONLY MASTER THREAD WILL EXECUTE IT.
		if(t_ID == 0)
		{
			thread POOL[nThread+1];
			bool tCratFlag = true;//! POOL thread creation flag.
			Graph::Graph_Node *mVItr;
			while(true)
			{
				if(tCratFlag == true) {
					//! Creating n POOL Threads
					for(int i = 1; i <= nThread; i++)
						POOL[i] = thread(concValidator, i);

					tCratFlag = false;
				}
				//! All Valid AUs executed.
				if(eAUCount == gNodeCount) {
					for(int i = 1; i <= nThread; i++)
						//! -1 = threads can join now.
						status[i] = -1;

					//! POOL thread join.
					for(int i = 1; i <= nThread; i++)
						POOL[i].join( );

					break;
				}
				mVItr = nValBG->verHead->next;
				while(mVItr != nValBG->verTail) {
					if(mVItr->in_count == 0) {
						for(int i = 1; i <= nThread; i++) {
							//! 0 = thread is available.
							if(status[i] == 0) {
								//! assigning node ref for
								//! thread in pool to execute.
								Gref[i] = mVItr;
								//! 1 = ref is available to execute.
								status[i] = 1;
								break;
							}
						}
					}
					mVItr = mVItr->next;
				}
			}
		}
		//! EXECCUTED BY nThread WORKER THREADS.
		else
		{
			while(true)
			{
				if(status[t_ID] == -1 || eAUCount == gNodeCount) 
					break;//! All task done.
				
				if(status[t_ID] == 1)//! Task available to work on.
				{
					Graph::Graph_Node *verTemp;
					verTemp  = Gref[t_ID];
					if(verTemp->in_count == 0)
					{
						if(verTemp->in_count < 0) {
							status[t_ID] = 0;
						}
						else
						{
							//! expected in_degree is 0 then
							//! vertex can be executed if 
							//! not claimed by other thread.
							int expected = 0;
							if(atomic_compare_exchange_strong( 
								&(verTemp->in_count), &expected, -1 ) == true)
							{
								verTemp->in_count = -1;
								//! get AU to execute, which is of string type;
								//! listAUs index statrt with 0 => -1.
								istringstream ss(listAUs[(verTemp->AU_ID)-1]);
								string tmp;
								//! AU_ID to Execute.
								ss >> tmp;
								int AU_ID = stoi(tmp);
								//! Function Name (smart contract).
								ss >> tmp;
								if( tmp.compare("get_bal") == 0 )
								{
									//! get balance of SObj/id.
									ss >> tmp;
									int s_id = stoi(tmp);
									int bal  = 0;
									//! get_bal() of smart contract.
									int v = coin->get_bal(s_id, &bal);
									if(v == -1) {
										mm = true;
										//! -1 = threads must join
										//! bcz miner is malicious.
										for(int i = 1; i <= nThread; i++)
											status[i] = -1;
									}
								}
								if( tmp.compare("send") == 0 )
								{
									//! Sender ID.
									ss >> tmp;
									int s_id = stoi(tmp);
									//! Reciver ID.
									ss >> tmp;
									int r_id = stoi(tmp);
									//! Ammount to send.
									ss >> tmp;
									int amt = stoi(tmp);
									int v = coin->send(s_id, r_id, amt);
									if(v == -1) {
										mm = true;
										//! -1 = threads must join
										//! bcz miner is malicious.
										for(int i = 1; i <= nThread; i++)
											status[i] = -1;
									}
								}
								Graph::EdgeNode *eTemp =verTemp->edgeHead->next;
								while( eTemp != verTemp->edgeTail) {
									Graph::Graph_Node* refVN = 
												(Graph::Graph_Node*)eTemp->ref;
									refVN->in_count--;
									eTemp = eTemp->next;
								}
								//! num of Valid AUs executed is eAUCount+1.
								eAUCount++;
							}
						}
					}
					//Gref[t_ID] = NULL;
					status[t_ID] = 0;
				}
			}
		}
		vTTime[t_ID] = vTTime[t_ID] + Ttimer._timeStop( start );
	}

	//!-------------------------------------------------
	//!FINAL STATE OF ALL THE SHARED OBJECT. Once all  |
	//!AUs executed. Geting this using get_bel_val()   |
	//!-------------------------------------------------
	void finalState()
	{
		for(int sid = 1; sid <= SObj; sid++) {
			int bal = 0, ts;
			bool v  = coin->get_bal(sid, &bal);
			ValidatorState[sid] = bal;
		}
	}

	~Validator() { };
};
/*************************Validator code ends**********************************/




//atPoss:: from which double-spending Tx to be stored at end of the list.
bool addMFS(int atPoss)//add malicious final state with double-spending Tx
{
	istringstream ss( listAUs[atPoss-2]);
	string trns1;
	ss >> trns1; //! AU_ID to Execute.
	int AU_ID1 = stoi(trns1);
	ss >> trns1;//function name
	ss >> trns1; //! Sender ID.
	int s_id = stoi(trns1);
	ss >> trns1; //! Reciver ID.
	int r_id = stoi(trns1);
	ss >> trns1; //! Ammount to send.
	int amtAB  = stoi(trns1);

	istringstream ss1( listAUs[atPoss-1]);
	ss1 >> trns1; //! AU_ID to Execute.
	int AU_ID2 = stoi(trns1);
	ss1 >> trns1;//function name
	ss1 >> trns1; //! Sender ID.
	int s_id1 = stoi(trns1);
	ss1 >> trns1; //! Reciver ID.
	int r_id1 = stoi(trns1);
	ss1 >> trns1; //! Ammount to send.
	int amtAC  = stoi(trns1);


	cGraph->remove_AU_Edge(cGraph, AU_ID1);
	cGraph->remove_AU_Edge(cGraph, AU_ID2);

	MinerState[s_id]  = 1000;
	MinerState[r_id]  = 1000;
	MinerState[r_id1] = 1000;

	amtAB = 950;
	trns1 = to_string(AU_ID1)+" send "+to_string(s_id)+" "
	       +to_string(r_id)+" "+to_string(amtAB)+"\n";
	listAUs[AU_ID1-1] =  trns1;
	
	amtAC = 100;
	trns1 = to_string(AU_ID2)+" send "+to_string(s_id)+" "
	       +to_string(r_id1)+" "+to_string(amtAC)+"\n";
	listAUs[AU_ID2-1] =  trns1;

	MinerState[s_id]  -= amtAB;
	MinerState[r_id]  += amtAB;
	MinerState[r_id1] += amtAC;
	return true;
}



bool stateVal() {
	//State Validation
	bool flag = false;
//	cout<<"\n"<<pl<<"SObject \tMiner \t\tValidator"<<endl;
	for(int sid = 1; sid <= SObj; sid++) {
//		cout<<sid<<" \t \t"<<MinerState[sid]
//			<<" \t\t"<<ValidatorState[sid]<<endl;
		if(MinerState[sid] != ValidatorState[sid]) flag = true;
	}
	return flag;
}



/*************************Main Fun code begins*********************************/
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
/*!!!!!!!!          main()         !!!!!!!!!!*/
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
int main( )
{
	cout<<pl<<"MVOSTM Miner and Fork-join SCV\n";
	cout<<"--------------------------------\n";
	//! list holds the avg time taken by miner and 
	//! Validator thread s for multiple consecutive runs.
	list<double>mItrT;
	list<double>vItrT;
	int totalDepInG  = 0; //to get total number of dependencies in graph;
	int totalRejCont = 0; //number of validator rejected the blocks;
	int maxAccepted  = 0;
	int totalRun     = NumBlock; //at least 2

	FILEOPR file_opr;

	//! read from input file:: SObj = #SObj; nThread = #threads;
	//! numAUs = #AUs; Î» =  % of edges to be removed from BG by malicious Miner.
	file_opr.getInp(&SObj, &nThread, &numAUs, &lemda);
	//! max shared object error handling.
	if(SObj > M_SharedObj) {
		SObj = M_SharedObj;
		cout<<"Max number of Shared Object can be "<<M_SharedObj<<"\n";
	}

	for(int numItr = 0; numItr < totalRun; numItr++)
	{
		 //! generates AUs (i.e. trans to be executed by miner & validator).
		file_opr.genAUs(numAUs, SObj, FUN_IN_CONT, listAUs);
		//! index+1 represents respective AU id, and
		//! mAUT[index] represents "time stamp (commited trans)".
		mAUT = new std::atomic<int>[numAUs];
		for(int i = 0; i< numAUs; i++) mAUT[i] = 0;
		tTime[0] = 0;
		tTime[1] = 0;
		mm = new std::atomic<bool>;
		mm = false;
		Timer mTimer;
		mTimer.start();

		//MINER
		Miner *miner = new Miner(0);
		miner ->mainMiner();

		if(lemda != 0) bool rv = addMFS(NumOfDoubleSTx);

		int totalEdginBG = cGraph->print_grpah();
		//give dependenices in the graph.
		if(numItr>0) totalDepInG += totalEdginBG;

		//VALIDATOR
		if(MValidation == true)
		{
			//Set Counter for malicious miner detection.
			coin->setCounterFlag(true);
				
			int acceptCount = 0, rejectCount = 0;
			for(int nval = 0; nval < numValidator; nval++)
			{
				Validator *validator = new Validator();
				nValBG = NULL;
				nValBG = new Graph;
				cGraph->copy_graph(nValBG);

				//If the miner is malicious this
				//fun remove an edge from graph.
				if(malMiner == true) {
					int eTR = ceil((totalEdginBG * lemda)/100);
					for(int r = 0; r < eTR; r++)
						nValBG->remove_Edge(nValBG);
				}

				validator ->mainValidator();

				//State Validation
				bool flag = stateVal();
				if(flag == true) rejectCount++;
				else acceptCount++;
				mm = false;
			}
			if(numItr > 0 && malMiner == true)
			{
				totalRejCont += rejectCount;
				if(maxAccepted < acceptCount ) maxAccepted = acceptCount;
			}
			for(int i = 1; i <= SObj; i++) ValidatorState[i] = 0;
		}
		else
		{
			Validator *validator = new Validator();
			nValBG = new Graph;
			cGraph->copy_graph(nValBG);
			validator ->mainValidator();
			//State Validation
			bool flag = stateVal();
			if(flag == true) cout<<"\nBlock Rejected by Validator";
		}
		int abortCnt = 0;
		for( int iii = 0; iii < nThread; iii++ ) {
			abortCnt = abortCnt + aCount[iii];
		}

		mTimer.stop();

		//total valid AUs among total AUs executed
		//by miner and varified by Validator.
		int vAUs = gNodeCount;
		if(numItr > 0)//skip first run
			file_opr.writeOpt(SObj, nThread, numAUs, tTime, mTTime,
			                        vTTime, aCount, vAUs, mItrT, vItrT);

		for(int i = 1; i <= SObj; i++) {
			MinerState[i]     = 0;
			ValidatorState[i] = 0;
		}
		listAUs.clear();
		delete miner;
		miner = NULL;
		delete cGraph;
		cGraph = NULL;
	}

	//! to get total avg miner and validator
	//! time after number of totalRun runs.
	double tAvgMinerT = 0, tAvgValidT = 0;
	auto mit = mItrT.begin();
	auto vit = vItrT.begin();
	for(int j = 1; j < totalRun; j++){
		tAvgMinerT = tAvgMinerT + *mit;
		tAvgValidT = tAvgValidT + *vit;mit++;
		vit++;
	}
	tAvgMinerT = tAvgMinerT/(totalRun-1);
	tAvgValidT = tAvgValidT/(totalRun-1);
	
	cout<<"    Total Avg Miner       = "<<tAvgMinerT<<" microseconds";
	cout<<"\nTotal Avg Validator       = "<<tAvgValidT<<" microseconds";
	cout<<"\n--------------------------------";
	cout<<"\nAvg Dependencies in Graph = "<<totalDepInG/(totalRun-1);
	cout<<"\n--------------------------------";
	cout<<"\nAvg Number of Validator Accepted the Block = "
		<<(numValidator-(totalRejCont/(totalRun-1)));
	cout<<"\nAvg Number of Validator Rejcted the Block  = "
		<<totalRejCont/(totalRun-1);
	cout<<"\nMax Validator Accepted any Block = "<<maxAccepted;
	cout<<"\n"<<endl;

	mItrT.clear();
	vItrT.clear();
	delete mTTime;
	delete vTTime;
	delete aCount;
	return 0;
}
/*************************Main Fun code ends***********************************/
